---
description: High-level architecture and design decisions for the RAG AI agent
globs: 
alwaysApply: false
---

## Architecture Rule

All new features must follow modular layering:
- Input Layer
- Retrieval Layer
- Orchestration Layer
- Generation Layer

Never mix retrieval logic with response formatting.

## Overview

This project is a RAG (Retrieval-Augmented Generation) AI agent. Components are organized as follows:

- **app/agents** – Agent orchestration (e.g. ragAgent.ts)
- **app/chains** – Reusable LLM chains (e.g. retrievalChain.ts)
- **app/embeddings** – Embedding utilities (embedder.ts)
- **app/vectorstore** – Vector store / Pinecone (pineconeClient.ts)
- **app/ingestion** – PDF processing (pdfProcessor.ts)
- **app/prompts** – Prompt templates (systemPrompt, ragPrompt)
- **app/routes** – API routes (upload, chat)
- **app/config** – Env and config (env.ts)
- **app/observability** – LangSmith (langsmith.ts)

## Data Flow

1. User input → agent
2. Agent may call retrieval (vectorstore) and/or tools
3. Retrieved context + tools output → chain → response

## Conventions

- Prefer dependency injection for LLM, embeddings, and vector store so they can be swapped or mocked.
- Keep retrieval and generation concerns separate; compose them in agents/chains.
